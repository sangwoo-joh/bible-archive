---
layout: page
title: How OCaml Type Checker Works
grand_parent: Learning
parent: Type Theory
---

{: .no_toc }
# [How OCaml Type Checker Works - or What Polymorphism and Garbage Collection Have In Common](https://okmij.org/ftp/ML/generalization.html)

 힌들리-밀너 타입 추론에는 알고리즘 W 말고도 좀 더 많은 것이
 있다. 1988년에, 디디어 레미(Didier Remy)는 Caml의 타입 추론 속도를
 높일려고 하고 있었는데, 타입 일반화(type generalization)를 위한
 우아한 방법을 발견했다. 타입 환경(type environment)을 스캐닝하지
 않아도 되서 빠를 뿐만이 아니다. 이 방법은 로컬에 선언되었지만
 보편적(universal; $$ \forall $$) 또는 존재적(existential; $$ \exists
 $$) 양화로 빠져나가는(escape) 타입을 잡을 수 있게 스무스하게
 확장된다.

 OCaml 타입 체커의 알고리즘과 구현은 모두 거의 알려져있지 않고 또 거의
 문서화되어 있지 않다. 이 페이지는 레미의 알고리즘을 설명하고 널리
 알리려 한다. 또, OCaml 타입 체커의 일부를 해석하려는 시도다. 레미의
 알고리즘의 역사 또한 보존하고자 한다.

 레미의 알고리즘의 매력은 타입 일반화를 일종의 의존성 추적으로 바라본
 통찰력에 있다. 이는 (메모리) 구역과 세대별 가비지 콜렉션과 같은 자동
 메모리 관리에서 쓰이는 추적 방법과 같은 종류이다. (타입) 일반화는
 노드에는 타입을 어노테이트하고 엣지는 공유된 타입을 나타내도록 표현한
 AST에서 도미네이터를 찾는 일로 볼 수 있다.


## Table of Contents
{: .no_toc .text-delta }
- TOC
{:toc}

## Introduction
 이 페이지는 원래 광범위하고, 복잡하고, 거의 문서화가 안된 OCaml 타입
 체커 코드를 이해하기 위해서 작성하던 노트로 시작했다. 코드를 파고
 들어가 보니 엄청난 보물이 발견되었다. 그 중 하나인 효율적이고 우아한
 타입 일반화 방법을 여기서 소개한다.

 OCaml의 타입 일반화는 이른바 타입의 *레벨(levels)* 추적
 기반이다. 완전히 같은 레벨은 모듈 안에 정의된 타입이 더 넓은 범위로
 빠져나가는(escape) 것을 막아준다. 따라서 레벨은 지역적으로 도입된
 타입 생성자에게 구역 규율(region discipline)을 강제한다. 일반화와
 구역이 아주 균일한 방법으로 처리되는 것은 굉장히 흥미롭다. OCaml 타입
 체커에서 레벨은 더 많은 쓰임새가 있는데, 폴리모픽 필드와 존재
 양화사(existential)를 가진 레코드에도 쓰인다. MetaOCaml은 미래에 쓰일
 (future-stage) 바인딩 범위를 추적하기 위해서 레벨에 간접적으로
 의존하고 있었다. 이런 모든 어플리케이션에는 공통적인 불평이 있었는데,
 의존성을 추적하는 일과 구역 억제 또는 데이터 의존 그래프의
 도미네이터를 계산하는 일이었다. 하나는 곧바로 Tofte와 Talpin의 구역
 기반의 메모리 관리를 떠올리게 한다. Fluet과 Morrisett이 보여줬듯이,
 구역을 위한 Tofte와 Taplin 타입 시스템은 할당된 데이터가 그 구역에서
 빠져나가는 것을 정적으로 막기 위해서 보편 양화사에 의존하여 System
 F에서 인코딩될 수 있다. 이것과 듀얼하게, 레벨 기반 일반화는 타입
 변수의 구역을 결정하기 위해서 타입 변수가 빠져나가는 것을 추적하는
 것에 의존하고, 따라서 보편 양화사를 위한 장소이다.

 OCaml의 일반화는 1988년에 디디어 레미에 의해 발견된 알고리즘의
 (부분적인) 구현이다. 이 아이디어는 타입이 명시된 AST 위에서 타입의
 공유를 명시적으로 표현하는 것이다. 타입 변수는 오직 그 변수의 모든
 발생(all occurrences)을 도미네이트하는 노드에서만 양화될 수
 있다. 타입 일반화는 그래프 도미네이터의 증분 계산에 해당한다. 레미의
 MLF는 이 아이디어의 자연스러운 결과물이다.

 아쉽게도, 레미의 일반화 알고리즘과 그 기저의 아이디어는 거의 알려져
 있지 않다. OCaml에 있는 것과 같은 구현은 OCaml 소스 코드에 아주 짧고
 헷갈리게 작성된 주석 외에는 전혀 문서화되어 있지 않는 것 같다. 이건
 널리 알려져야 한다. 이를 위해서, (1) 알고리즘에 대한 동기 부여와
 설명을 해서 그 직관과 뼈대 구현을 드러내고, (2) OCaml 타입 체커를
 해석한다.

 이 글의 두 번째 파트는 OCaml 타입 체커의 일부분에 주석을 다는 것이
 목적이고, 따라서, 꽤 기술적이다. OCaml 4.00.1 버전의 타입 체킹 코드를
 참조하고 있다. `typing/` 디렉토리 안에 있다. `typecore.ml` 파일이
 타입 체커의 핵심이다. AST의 노드를 타입과 타이핑 환경으로
 어노테이트한다. 정확히는, `parsing/parsetree.mli`에 정의된
 `Parsetree`를 `Typedtree`로 변환한다. `ctype.ml` 파일은 유니피케이션
 알고리즘과 레벨 조작 함수를 구현하고 있다.

## Generalization

 이 배경 설명에서는 힌들리 밀너 타입 시스템의 타입 일반화를 설명하고
 나이브한 구현의 미묘한 점과 비효율적인 점을 강조한다. 이 비효율은
 레미가 레벨 기반 일반화 알고리즘을 발견하는 동기가 되었다.

 타입 환경 `G`에 대한 타입 `t`의 *일반화(generalization)* `GEN(G,
 t)`가 `G`에서 자유로 나타나지 않는 `t`의 자유 타입 변수를 양화하는
 것임을 떠올려보자. 즉, `GET(G, t) = ` $$ \forall \alpha_1
 ... \alpha_n .$$ `t` where $$ { \alpha_1, ..., \alpha_n} = $$
 `FV(t) - FV(G)`. 힌들리 밀너 식으로 얘기하면, 이 양화는 타입을 이른바
 타입 스키마(type schema)로 바꾼다. 일반화는 `let` 표현식의 타입
 체킹에 쓰인다.

```
G ㅏ e : t     G, (x: GEN(G, t)) ㅏ e2 : t2
---------------------------------------------
G ㅏ let x = e in e2 : t2
```

 즉, `let` 바운드 변수에 추론된 타입은 `let` 표현식의 바디를 타입
 체킹할 때 일반화된다. ML은 일반화에 조건을 추가하는데, 이른바 값
 제약(value restriction)이다. `let` 바운드 표현식 `e`는 겉보기에는
 반드시 눈에 보이는 사이드 이펙트가 없어야 한다. 기술적으로는, `e`는
 반드시 *비확장성(nonexpansive)*이라는 문법 테스트를 통과해야
 한다. OCaml은 이 값 제약을 완화하는데, 뒤에서 나온다.

 일반화의 단순한 예시는 다음과 같다.

```ocaml
fun x -> let y = fun z -> z in y
(* 'a -> ('b -> 'b) *)
```

 타입 체커는 `fun z -> z`에 대해서 새로운, 그래서 유니크한 타입 변수
 $$ \beta $$를 도입하여 $$ \beta \to \beta $$ 타입을 추론한다. 표현식
 `fun z -> z`는 문법적으로는 값이고, 일반화가 진행되고, 그래서 `y`는
 타입 $$ \forall \beta. \beta \to \beta$$를 갖는다. 폴리모픽 타입이기
 때문에, `y`는 다른 타입 문맥에서 등장할 수도 있다. 즉, 다른 타입의
 아규먼트에 적용될 수도 있다. 예를 들면 다음과 같다.

```ocaml
fun x ->
  let y = fun z -> z in
  (y 1, y true)
(* 'a -> int * bool *)
```

 일반화 `GEN(G, t)`는 `G`에 나타나지 않는 `t`의 자유 타입 변수에
 대해서*만* 양화한다. 이 조건은 미묘하지만 아주 중요하다. 이게 없으면,
 $$ \alpha \to \beta $$ 같은 불안전한 타입이 다음 함수에 대해서 추론될
 수 있다.

```ocaml
fun x -> let y = x in y
```

 함수 타입을 추론하려면, 먼저 함수의 바디 `let y = x in y`의 타입을
 새로운 타입 변수 `'a`($$\alpha$$)가 도입된 타입 환경 `x:'a`에서
 추론한다. 위의 `let` 규칙에 의해서 `y`에 타입이 추론되는데,
 결과적으로 타입 `GEN(x:'a, 'a)`를 추론한다. 분명히 `'a`는 타입 환경
 `x:'a`에서 나타난다. 그럼에도 불구하고 여기에 양화를 해버리면, `y`는
 폴리모픽 타입 $$ \forall \alpha. \alpha$$를 받게 되고, 따라서 어떤
 타입으로든 인스턴스화 될 수 있다. 그 결과 함수는 표면적으로
 아규먼트를 그 어떤 타입으로 바꿀 수 있게 된다.

 따라서, 양화할 각각의 타입 변수에 대해서 우리는 반드시 **타입 환경에
 나타나지 않음**을 확인해야 한다. 나이브하게 생각하면, 그냥 타입
 환경을 다 스캔해서 모든 바인딩의 타입을 살펴볼 수 있다. 사실, 원래
 Caml이 정확히 이걸 구현했었다. 하지만 타입 환경은 엄청나게 커질 수
 있다. 일반적으로 ML 함수들은 아주 긴 `let` 표현식 시퀀스를 담고
 있다. 일반적인 `let`은 이전에 나타난 모든 `let`들의 바인딩을 타입
 환경에 갖고 있다. 재귀적인 `let`의 환경은 모든 `let` 형제(sibling)의
 바인딩을 갖고 있다. 하나의 `let`에 대한 일반화의 일부로 이 환경을
 스캔하면 함수 크기에 대해 선형 시간이 걸린다. 그러면 전체 프로그램의
 타입 체킹은 제곱이 된다. 레미가 회상하기로 비효율적인 일반화는 Caml
 컴파일의 느린 속도의 주된 이유 중 하나였다. 컴파일러를
 부트스트래핑하면서 패턴과 표현식을 컴파일하기 위해서 두 개의 상호
 재귀 함수를 타입 체킹하는 일은 거의 20분 걸렸다.

 타입 환경을 스캔하지 않는 방법이 있어야 한다.

## Unsound generalization as memory mismanagement

 여기서는 먼저 레미의 알고리즘 뒤에 있는 아이디어를 구역 기반 메모리
 관리와 관련지어 소개한다. 구체성을 위해서 토이 힌들리 밀너 타입
 추론기를 쓸 것이다. 여기서 추론기는 타입 환경을 고려하지 않고 타입의
 자유 타입 변수를 양화하는 *불안전한(unsound)* 일반화 함수를 갖고
 있다. 세 가지 간단한 예시를 타입 체크할 것이고, 불안전한 타입을
 추론하는 일을 수동 메모리 관리에서의 일반적인 문제와 연관지을 것이다:
 여전히 사용 중인 메모리를 해제하는 일이다. 불안전한 일반화는 이 다음
 섹션에서 수정되는데, 자원의 성급한 해제를 막는 표준적인 방법에서
 영감을 얻었다.

 우리의 힌들리 밀너 타입 추론기가 장난감이긴 하지만, 진짜 OCaml 타입
 체커의 많은 구현적인 결정(그리고 몇몇 함수 이름)을 공유한다. 이걸
 이해하면 나중에 OCaml 내부를 살펴볼 때 많은 도움이 된다.

 우리의 토이 언어는 표준적인 순수 람다 대수에 `let`을 추가한 것이다.

```ocaml

```

## Efficient generalization with levels
## Even more efficient level-based generalization
## Type Regions
## Discovery of levels

## Inside the OCaml Type Checker
### Generalization with levels in OCaml
### Type Regions
### Creating fresh type variables
### True complexity of generalization
