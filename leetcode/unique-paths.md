---
layout: default
title: Unique Paths
parent: LeetCode
---

# Unique Paths
 `m x n` 격자판이 주어지고 왼쪽 제일 위에 로봇이 있다. 로봇은 한 번에
 한 칸 오른쪽 또는 아래로 움직일 수 있다. 최종적으로는 오른쪽 제일
 아래로 가려고 한다. 이때 가능한 "유니크 경로"의 개수는?

 예를 들어, `m = 3`, `n = 2` 라고 하자. 그러면 가능한 경우는 총 세
 가지이다.
  1. 오른쪽 -> 아래 -> 아래
  2. 아래 -> 아래 -> 오른쪽
  3. 아래 -> 오른쪽 -> 아래

## Brute Force
 가장 무식하게 풀면 다음과 같이 풀 수 있다.

```python
def unique_paths(m, n):
    def walk(x, y):
        if x == m or y == n:
            return 1
        return walk(x+1, y) + walk(x, y+1)
    return walk(1, 1)
```
 - 시작 지점을 `(1, 1)`, 도착 지점을 `(m, n)` 으로 모델링하면 한 번에
   아래(`x + 1`) 또는 오른쪽(`y + 1`)으로 움직일 수 있다.
 - 아래로만 or 오른쪽으로만 움직이는 경우, 도달할 수 있는 가지수는
   1가지다.
 - 그럼 그 외의 경우, 즉 섞어서 움직이는 경우는 어떻게 될까? 이때는
   바로 위쪽 쎌로 도달 가능한 가지수 + 바로 왼쪽 쎌로 도달 가능한
   가지수가 된다.

 마지막이 잘 와닿지 않아서 좀더 구체적인 예시를 가져와 보았다. 아래와
 같은 `3 x 2` 격자를 생각해보자.

```
(1, 1) (1, 2)
(2, 1) (2, 2)
(3, 1) (3, 2)
```

 그러면 일단 아래로만 or 오른쪽으로만 움직이는 경우는 다음과 같다.

```
| 0 | 1 |
| 1 |   |
| 1 |   |
```

 이때 `(2, 2)`에 도달 가능한 경로 수는 몇 개일까? 앞서 말한 것처럼
 바로 위쪽 쎌인 `(1, 2)`의 가지수와 바로 왼쪽 쎌인 `(2, 1)`의 가지수를
 합한 수가 된다.

```
| 0 | 1 |
| 1 | 2 |
| 1 |   |
```

 그러면 목표 지점인 `(3, 2)`에 도달 가능한 경로 수는 자연스럽게 `(2,
 2)`까지 도달 가능한 경로 수와 `(3, 1)`까지 도달 가능한 경로 수의 합이
 된다.

```
| 0 | 1 |
| 1 | 2 |
| 1 | 3 |
```

## 메모아이제이션
 좀더 큰 격자를 생각해보면, 여기서도 중복되는 부분이 있음을 알 수
 있다. 예를 들어 다음과 같이 큰 격자가 있을 때,

```
| 0 | 1 | 1 | 1 | 1 |
| 1 | 2 |   |   |   |
| 1 |   |   |   |   |
```

 여기서 빈칸 중 하나인 `(3, 3)`을 계산하려면, 바로 직전(위/왼) 쎌들인
 `(3, 2)`와 `(2, 3)`을 알아야 한다. 마찬가지로 `(3, 4)`를 계산하려면
 직전 쎌들인 `(3, 3)`과 `(2, 4)`를 알아야 하고 여기서 `(3, 3)`이
 중복된다. ... 이런 식으로 쭉 이전 계산을 재활용하게 된다.

 따라서 위의 Brute Force 버전의 중간 결과를 캐싱하면, 손쉽게 풀린다.

```python
from functools import cache
def unique_paths(m, n):
    @cache
    def walk(x, y):
        if x == m or y == n:
            return 1
        return walk(x+1, y) + walk(x, y+1)
    return walk(1, 1)
```
