---
layout: page
title: Triangle Path
parent: Jongman Book Training
---

{: .no_toc }
## Table of Contents
{: .no_toc .text-delta }
- TOC
{:toc}

# Description
 직각 삼각형으로 배치된 자연수가 있다. 제일 윗칸에서 시작해서 제일
 아랫줄까지 가려고 한다. 한 번에 한 칸씩 아래로 내려갈 수 있는데, 바로
 아랫칸 또는 오른쪽 아랫칸으로 갈 수 있다. 이때 가능한 모든 경로
 중에서 숫자의 합이 가장 큰 값을 구하자.

 삼각형의 크기는 `2 <= n <= 100`이고 숫자는 100000 이하의 자연수이다.

# Solution
 일단 완전 탐색을 고려해보면 다음과 같다.

 현재 위치가 `(y, x)` 이고 (여기선 이 정확한 표현방법을 써야함),
 지금까지 만난 수의 합을 `sum` 이라고 할 때, 그 다음 가능한 경로(의
 숫자 합)은 다음 둘 중 더 큰 값이 된다:
  - `(y+1, x)` 로 이동하면서 `sum += triangle[y][x]` 으로 업데이트
  - `(y+1, x+1)` 로 이동하면서 `sum += triangle[y][x]` 으로 업데이트

 이렇게하면 완전 탐색하는 함수 `path(y, x, sum)`을 구현할 수 있지만,
 모든 경로를 다 뒤져보기 때문에 복잡도가 기하급수적으로 증가한다. 현재
 위치에서 다음 위치를 고를 수 있는 방법이 두 가지이기 때문에 정말로
 경로 수가 `2^(n-1)` 가지다.

 그럼 최대한 단순하게 메모아이제이션을 적용하면 어떨까? 저 `path(y, x,
 sum)` 자체에 `lru_cache`를 씌워버리면 안될까? 문제의 조건에 따르면
 삼각형의 크기는 최대 100이고 삼각형에 적힌 숫자는 최대 10000 이므로
 가능한 `sum`의 경우의 수는 총 100 x 10000 = 1000000이 된다. 이걸 다
 캐싱하는게 불가능하진 않지만 너무 크고 비효율적이다. 게다가 서로 다른
 경로에 대해서 숫자의 합이 항상 다른 입력이 들어올 경우, `sum` 값을
 같이 캐싱하는건 전혀 의미가 없어서 그냥 공간만 더 낭비하는 완전
 탐색이랑 똑같이 동작한다.

 그런데 과연 `sum` 이라는 정보를 캐싱하는게 의미가 있을까? `(y,
 x)`에서부터 가장 아랫줄까지 내려가는 경로의 숫자의 합 최대 값은 그
 이전까지 누적한 `sum`의 값와 상관없이 항상 같다. 다시 말해,
 `sum`이라는 정보는 `(y, x)`에서 맨 아랫줄까지 내려가는 경로를
 최적화하는 문제와 아무런 관계가 없다. 지금(`(y, x)`)까지 어떤 경로로
 도착했던간에(`sum` 값과 상관없이), 나머지 문제(맨 아랫줄까지 가는
 경로)를 항상 최적으로 풀어도 된다는 뜻이다. 이런 조건을 *최적 부분
 구조(Optimal Substructure)*라고 한다. **각 부분 문제의 최적해만
 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있는 경우**를 뜻한다.

 따라서 `(y, x)` 에서 시작해서 맨 아랫줄까지 가는 부분 경로의 최대
 합을 반환하는 함수를 메모아이제이션 한 후에 `(0, 0)`(맨 꼭대기)에서
 시작하면 우리가 원하는 답을 구할 수 있다.

# Code

```python
@lru_cache(maxsize=None)
def path(y, x):
    if y == n - 1:
        # 맨 아랫줄에 도달 - y 값만 체크하면 됨
        return triangle[y][x]
    # 바로 아랫칸 또는 오른쪽 아랫칸으로 가는 경로의 합 중 최대 값에 현재 값을 누적
    return max(path(y+1, x), path(y+1, x+1)) + triangle[y][x]
```
