---
layout: page
tags: [problem-solving, theory, bitwise]
title: Bitwise Property
grand_parent: Problem Solving
parent: Theory
---

{: .no_toc }
# Bitwise Property

## Table of Contents
{: .no_toc .text-delta }
- TOC
{:toc}


## 2의 배수 알아내기

 2의 보수 성질에 의해 다음 등식이 성립한다: x = ~x + 1

 예를 들어 x = 7 이고 8비트만 살펴보면 다음과 같다.

```
 0  0  0  0  0  1  1  1      x = 7
 1  1  1  1  1  0  0  0      ~x
 1  1  1  1  1  0  0  1      ~x + 1 == -x
```

 따라서 `x + (~x + 1)`을 계산해보면 모든 1이 사라지고 전부 0이
 된다. 그러므로 `~x + 1 == -x`이다.

 바이너리 표현에서 2의 보수에 의한 x와 -x의 관계를 알았으니 이 두 수를
 가지고 할 수 있는 것 중 하나를 살펴보자. 바로 x에서 가장 오른쪽에
 있는 1의 위치를 알아내는 방법이다.

```
x = 7
 0  0  0  0  0  1  1  1      x
 1  1  1  1  1  0  0  1      -x
 0  0  0  0  0  0  0  1      x & -x

x = 6
 0  0  0  0  0  1  1  0      x
 1  1  1  1  1  0  1  0      -x
 0  0  0  0  0  0  1  0      x & -x
```

 즉, `x & -x`를 하면 가장 오른쪽에 있는 1 하나(바로 이게 2의 보수
 표현을 위해서 더해진 1)만 남기고 다 Unset 된다.

 이제 2의 배수인 경우에 이 연산이 어떻게 동작하는지 살펴보자. 예를
 들어 x = 16인 경우는 다음과 같다.

```
x = 16
 0  0  0  1  0  0  0  0      x
 1  1  1  0  0  0  0  1      -x
 0  0  0  1  0  0  0  0      x & -x
```

 결과를 보면 2의 배수인 경우 `x & -x == x` 임을 알 수 있다. 이는
 생각해보면 매우 당연한 일이다.
 - 바이너리로 표현된 2의 배수는 딱 하나의 비트만 1이다.
 - `x & -x`는 가장 오른쪽에 있는 1 하나만 남긴다.
 - 그러므로 2의 배수는 가장 오른쪽에 있는 1 하나만 남긴 수와 같다.

 요약하면, `x & -x`는 가장 오른쪽에 있는 1인 비트 하나만을 **남기는**
 연산이고 이를 이용해서 2의 배수를 판별할 수 있다.

---

 이와 듀얼인 연산을 이용하는 다른 접근 방법도 있다. 즉 가장 오른쪽에
 있는 1인 비트를 *남기는*게 아니라, **지워버리는** 방법이다.

 먼저 x와 x-1의 관계를 살펴보자.

```
x = 7
 0  0  0  0  0  1  1  1      x
 0  0  0  0  0  1  1  0      x - 1
 0  0  0  0  0  1  1  0      x & (x - 1)

x = 6
 0  0  0  0  0  1  1  0      x
 0  0  0  0  0  1  0  1      x - 1
 0  0  0  0  0  1  0  0      x & (x - 1)
```

즉, `x & (x - 1)`은 가장 오른쪽에 있는 1인 비트 하나만을 **지우는**
연산이다. 1을 빼는 것과는 다르다는 것에 주의하자.

이제 마찬가지로 2의 배수인 경우에 이 연산이 어떻게 동작하는지
살펴보자.

```
x = 16
 0  0  0  1  0  0  0  0      x
 0  0  0  0  1  1  1  1      x - 1
 0  0  0  0  0  0  0  0      x & (x - 1)
```

 결과를 보면 2의 배수인 경우 `x & (x - 1) == 0`임을 알 수 있다. `x &
 (x - 1)` 연산이 가장 오른쪽의 1을 지워버리기 때문에, 이는 역시 매우
 당연한 일이다.

 따라서 두 가지 비트 연산을 통해 어떤 수가 2의 배수인지 아닌지를
 빠르게 판변할 수 있다.
 - `x & -x == x`
 - `x & (x - 1) == 0`
