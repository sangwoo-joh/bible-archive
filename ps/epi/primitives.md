---
layout: page
title: Primitive Types
parent: Elements of Programming Interviews in Python
grand_parent: Problem Solving
---


# Primitive Types

## Computing the parity of a word
 **패리티**란 바이너리 워드 안에서 1의 개수가 짝수이면 0, 홀수이면 1인
 값이다. 예를 들어 1011의 패리티는 1이고 10001000의 패리티는
 0이다. 패리티 체크는 데이터를 저장하거나 통신할 때 싱글 비트 오류를
 찾아내는데 쓰인다.

 64비트 워드의 패리티를 어떻게 계산할 수 있을까?


### Brute force

```python
def parity(x):
  res = 0
  while x:
    res ^= x & 1
    x = x >> 1
  return res
```

 - 복잡도는 O(n)이고 n은 워드의 크기이다.
 - `&` 연산으로 최하위 1비트씩 가져온다.
 - xor 연산의 성질인 "서로 다른 값일 때만 1, 같으면 0"을 이용해서
   비트를 계속 뒤집는다(flip). 초기값이 0이므로 1이 홀수개면 1,
   짝수개면 0이 된다. 초기값이 1이었다면 이것과 정반대의 결과를
   얻는다.

### 비트 성질 이용
 가장 낮은 위치의 비트가 LSB이고 가장 높은 위치의 비트가 MSB이다.

 `x - 1`을 하면, LSB부터 LSB에서 가장 가까운 첫번째 1인 비트까지가
 전부 뒤집힌다. 예를 들어서 `x = 00101100` 이면 `x - 1 = 00101011`이
 된다. 이는 정수가 2의 보수로 표현되기 때문이다.

 이 성질을 이용해서, `x & (x - 1)`을 하면 가장 낮은 위치의 1인 비트를
 삭제할 수 있다. 위의 예시에서 `x = 00101100` 이면 `x & (x - 1) =
 00101000`이 되어서 최하위에 위치해있던 `100`이 사라진다.

 이걸 바탕으로 좀더 최적화된 구현을 하면 다음과 같다.

```python
def parity(x):
  res = 0
  while x:
    res ^= 1
    x = x & (x - 1)
  return res
```

 - `x & (x - 1)`이 최하위에 있는 1을 하나씩 없앤다는 성질을 이용해서,
   `res`에는 항상 1을 flip 한다.
 - 복잡도는 O(k)가 되는데 이때 k는 워드 x가 갖고 있는 1의 개수이다.

### 캐싱
 대부분의 최적화는 캐싱(해시 테이블)이다.

 패리티의 중요한 성질 중 하나는 바로 **결합법칙(associative)**이
 성립한다는 점이다. 즉, 어떤 *비트의 집합*에 대해서 패리티를 구할 때,
 부분에 대한 패리티 값끼리 패리티 연산을 해도 최종 결과에 영향을 주지
 않는다.

 이 성질을 이용해서, 입력이 8비트 워드일 때를 생각해보자. 이걸 2비트씩
 쪼갠다고 하자. 그러면 `00`, `01`, `10`, `11`이 되고 각각의 패리티
 값은 (0, 1, 1, 0)이 된다. 그러면 패리티의 결합법칙에 의해, 8비트
 입력을 2비트씩 쪼갠 후 패리티를 구하고, 이를 다시 전체 패리티 연산에
 합치면 8비트 전체에 대한 패리티를 구한 결과와 같다.

 이를 코드로 풀면 대충 다음과 같다. 여기서는 16비트씩 캐싱하도록
 했다. 16비트면 대충 64k인데 이정도는 충분히 작아서 캐싱할 만하고,
 64는 16으로 나누어 떨어지기 때문에 괜찮다.

```python
def parity(x):
  MASK_SIZE = 16
  BIT_MASK = 0xffff
  return (CACHE[x >> (3 * MASK_SIZE)]
          ^ CACHE[(x >> (2 * MASK_SIZE)) & BIT_MASK]
          ^ CACHE[(x >> MASK_SIZE) & BIT_MASK]
          ^ CACHE[x & BIT_MASK])
```

 - 16비트씩 4개로 쪼갠 결과를 합치면 64비트의 패리티 값이 된다.
 - 최상위 16비트는 (64 - 16) = (16 * 3) = 48비트 만큼 땡기기만 하면
   된다. signed integer의 성질에 의해서 앞에 빈 공간은 0으로 채워지기
   때문이다.
 - 반면 중간에 낀 부분을 가져올 때는 윗부분의 값을 필터링해야
   한다. 이를 위해서 `BIT_MASK` 변수를 도입해서 `1111 1111 1111
   1111`의 값을 가지도록 하고 and 연산을 통해 16개만 남기고 싹
   날려버린다.
 - `CACHE`에는 패리티 값을 미리 계산해둬야 한다.
 - 복잡도는 O(n/L)이 되는데, 이때 L은 캐싱 키로 쓰인 워드의 사이즈이고
   n은 전체 사이즈이다. 여기서는 64/16 = 4가 된다.

### 패리티 성질 이용
 전부 1인 입력이 들어오면 앞선 알고리즘 중 일부는 힘을 못쓴다. 그나마
 캐싱이 낫긴 하지만 얘는 미리 룩업 테이블을 계산하는데 힘을 좀 써야
 한다.

 패리티의 성질을 이용하면 입력의 모양과 상관없이 괜찮은 성능을 낼 수
 있다. 구체적으로는 xor의 성질이다. 두 비트를 xor 연산하면 둘 다
 같으면 0 다르면 1이다. xor은 결합법칙이 성립하고, 또 교환법칙도
 성립한다. 즉, 비트를 어떻게 분리해서 연산한 다음 부분 결과를 다시
 연산한 거랑 전체를 연산한거랑 결과가 같고, 부분 중 어디부터
 연산할건지가 결과에 영향을 미치지 않는다. 즉, 둘 다 1인 것과 둘 다
 0인 부분은 0이 되어 사라지고, 둘 중 하나만 1인 부분만
 살아남는다. 패리티의 정의를 떠올려 보면, 1이 짝수개이면 0이고
 홀수개이면 1인데, 이는 다시 말해 1 ^ 1 = 0이 되고 1 ^ 0 = 0 ^ 1 = 1이
 되어 xor의 정의와도 부합하는 것이다.

 구체적인 예시를 보고 나서 이걸 일반화해보자. 8비트 워드 11010111의
 패리티를 다음과 같이 구해보자. 먼저 8비트를 4비트 씩 두 개로 쪼개서
 전체를 xor 연산해보자. 1101 ^ 0111 의 결과인 1010은 무엇을 뜻할까?
 앞서 말했듯 xor의 결과가 곧 패리티와도 같기 때문에, 이는 곧 4비트
 워드의 각 비트의 패리티 연산 결과와도 같다. 그럼 이 결과를 또 4비트의
 절반인 2비트와 xor 연산하게 되면, 즉 1010을 나눠서 10 ^ 10 을 한
 결과는 00이 되고 이는 곧 2비트 워드의 각 비트의 패리티 연산 결과와
 같다. 마지막으로 2비트의 절반인 1비트끼리 xor 연산을 하게 되면 최종
 결과는 0 ^ 0 = 0이 되고, 이게 우리가 구하고자 하는 최종 패리티 비트
 값이 된다.

 이제 이걸 일반화해보자. <b63, b62, ..., b1, b0> 비트를 생각하자. 이
 비트의 패리티 값은 <b63, b62, ..., b32>와 <b31, b30, ..., b0>의
 패리티를 xor 한 값과 같다. 이 두 32비트의 xor 연산은 하나의 명령어로
 처리할 수 있다. 이렇게 절반씩 나눠서 xor 연산 결과를 누적하는 것을
 계속하면 최종적으로 우리가 구하고자 하는 1비트 패리티 값을 얻을 수
 있다. 이를 코드로 쓰면 다음과 같다.

```python
def parity(x):
  SHIFT = 32
  while SHIFT:
    x ^= x >> SHIFT
    SHIFT = SHIFT // 2
  return x & 0x01
```

 - 복잡도는 워드에 있는 1의 개수에 영향을 받지 않는다. 문제를 절반 씩
   나눠서 풀기 때문에 복잡도는 O(logn)이 되고 이때 n은 워드의
   사이즈이다.
 - 여기서 더 빠르게 하려면, 워드 레벨에서 xor 연산을 직접 하지 않고
   중간 결과를 적당한 사이즈의 룩업 테이블로 캐싱해두는 방법도
   있다. xor 연산을 직접 하는 것보다 미리 계산해둔 캐싱 결과를
   가져오기만 하는 것이 더 빠를수도 있다.


## Swap bits
## Reverse bits
## Find a closest integer with the same weight
## Compute `x * y` without arithmetical operators
## Compute `x / y`
## Compute `x ^ y`
## Reverse digits
## Check if a decimal integer is a palindrome
## Generate uniform random numbers
## Rectangle intersection
