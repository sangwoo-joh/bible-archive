---
layout: page
title: 2. Combinator parsers
grand_parent: Work In Progress
parent: Monadic Parser Combinators
---

# 컴비네이터 파서
 먼저 옛 현인들의 컴비네이터 파싱에 대한 기본 아이디어를 리뷰하는
 것부터 시작하자. 구체적으로는 일단 파서와 세 개의 원시 파서, 더 큰
 파서를 만들기 위한 두 개의 원시 컴비네이터에 대한 타입부터 정의한다.

## 파서의 타입
 먼저 "파서"란 문자열을 입력으로 받아서 어떤 종류의 트리를 결과로
 내놓는 함수로 생각하는 것부터 시작하자. 트리는 문자열의 문법적 구조를
 명시적으로 드러낸다.

```ocaml
type parser = string -> tree
```

 하지만 일반적으로 파서는 입력 문자열을 전부 소모(consume)하지 않을
 수도 있는데, 그러므로 트리만 리턴하는 것보다는 입력 문자열에서 아직
 소모되지 않은 접두사 부분을 같이 리턴하자. 따라서 파서의 타입은
 다음과 같다.

```ocaml
type parser = string -> (tree * string)
```

 또 잘 생각해보면, 파서는 어떤 입력 문자열에 대해서 실패할 수도
 있다. 이럴 때 런타임 에러를 던지는 것보다는, 파서가 하나의 쌍이
 아니라 쌍의 리스트를 리턴하게 해서 빈 리스트는 파서의 실패를 알리도록
 하고 원소가 하나인 리스트(싱글톤)은 성공을 알리도록 할 수 있다.

```ocaml
type parser = string -> (tree * string) list
```

 명시적인 *실패* 표현을 가지며 입력 문자열에서 *소모되지 않은 부분*을
 리턴하는 일은 작은 파서로부터 더 큰 파서를 만들기 위한 컴비네이터를
 정의할 수 있게 해준다. 결과를 리스트로 리턴하는 것은 입력 문자열이
 하나 이상의 방법으로 파싱될 수 있을 때 원소가 하나 이상인 리스트를
 리턴할 수 있는 가능성을 열어주는데, 이는 곧 주어진 문법이
 모호(ambiguous)하다는 의미이다.

 마지마기으로, 서로 다른 파서는 서로 다른 종류의 트리를 리턴하기
 마련인데, 따라서 구체적인 트리의 타입을 추상화해서 파서의 타입을
 파라미터화 하는 것이 좋다.

```ocaml
type 'a parser = string -> ('a * string) list
```

 이게 바로 우리가 내내 얘기할 파서의 타입이다. 여기서 더 나아가면 입력
 문자열을 추상화할 수도 있는데 거기까지 가진 않을 것이다.
