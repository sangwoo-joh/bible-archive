---
layout: page
title: 2. Combinator parsers
grand_parent: Work In Progress
parent: Monadic Parser Combinators
---

# 2. 컴비네이터 파서
 먼저 옛 현인들의 컴비네이터 파싱에 대한 기본 아이디어를 리뷰하는
 것부터 시작하자. 구체적으로는 일단 파서와 세 개의 원시 파서, 더 큰
 파서를 만들기 위한 두 개의 원시 컴비네이터에 대한 타입부터 정의한다.

## 2.1. 파서의 타입
 먼저 "파서"란 문자열을 입력으로 받아서 어떤 종류의 트리를 결과로
 내놓는 함수로 생각하는 것부터 시작하자. 트리는 문자열의 문법적 구조를
 명시적으로 드러낸다.

```ocaml
type parser = string -> tree
```

 하지만 일반적으로 파서는 입력 문자열을 전부 소모(consume)하지 않을
 수도 있는데, 그러므로 트리만 리턴하는 것보다는 입력 문자열에서 아직
 소모되지 않은 접두사 부분을 같이 리턴하자. 따라서 파서의 타입은
 다음과 같다.

```ocaml
type parser = string -> (tree * string)
```

 또 잘 생각해보면, 파서는 어떤 입력 문자열에 대해서 실패할 수도
 있다. 이럴 때 런타임 에러를 던지는 것보다는, 파서가 어느 부분에서
 어떻게 실패했는지를 알려주면 좋을 것 같다. `Result` 타입을 이용하면
 좋을 것 같다.

```ocaml
type parser = string -> (tree * string) result
```

 명시적인 *실패* 표현을 가지며 입력 문자열에서 *소모되지 않은 부분*을
 리턴하는 일은 작은 파서로부터 더 큰 파서를 만들기 위한 컴비네이터를
 정의할 수 있게 해준다.

 서로 다른 파서는 서로 다른 종류의 트리를 리턴하기 마련인데, 따라서
 구체적인 트리의 타입을 추상화해서 파서의 타입을 파라미터화 하는 것이
 좋다.

```ocaml
type 'a parser = string -> ('a * string) result
```

 그리고 남은 입력을 계속 문자열로 리턴하게 되면 불필요한 복사가 많아질
 수 있다. 따라서, 입력 문자열에서 어디까지 진행했는지를 기록하기 위한
 위치 인덱스를 함께 갖고 있으면 좋을 것 같다.

```ocaml
type input =
  { text : string
  ; pos : int
  }
```

## 2.2. 원시(Primitive) 파서
 여기서 정의할 세 개의 원시 파서는 컴비네이터 파싱의 기본 구성
 요소이다. 첫 번째 파서는 `result v`로 입력 문자열을 아무것도 소모하지
 않고 성공하고 하나의 결과 `v`를 리턴한다.

```ocaml
let result : 'a -> 'a parser = fun v -> fun input -> [(v, input)]
```

 `result v`는 문자열 `input`을 입력으로 받아서 원소가 하나인 리스트
 `[(v, input)]`을 리턴하는 함수다.

 듀얼하게 파서 `zero`는 입력 문자열과 상관없이 항상 실패하는 파서이다.

```ocaml
let zero : 'a parser = fun input -> []
```

 마지막 프리미티브는 `item`인데 입력 문자열에 대해서 첫 번째 글자를
 성공적으로 소모하거나, 문자열이 비어있으면 실패하는 함수이다.

```ocaml
let item : char parser =
    fun input -> if input = "" then [] else (
        let x = String.get input 0 in
        let remain = String.sub input 1 (String.length input - 1) in
        [(x, remain)]
    )
```

## 2.3. 파서 컴비네이터
 앞서 정의한 원시 파서들은 그 자체로는 그다지 쓸모있지는
 않다. 여기서는 이 파서를 어떻게 이어 붙여서(glue) 더 유용한 파서를
 만들 수 있을지 살펴본다. 먼저 문법을 지정하기 위한 BNF 표기법에서,
 함수 적용이랑 비슷한 *시퀀싱(sequencing)* 연산자와 `|`로 표시되는
 *선택(choice)* 연산자를 이용해서 작은 문법으로부터 더 큰 문법을
 만드는 것을 살펴볼 것이다. 이렇게 정의된 연산자는 실제 문법의 구조와
 밀접한 방식으로 파서를 합치는 것을 도와준다.

 모나드 방식이 아닌 초창기의 컴비네이터 파싱에서, 파서의 시퀀싱 연산은
 보통 다음 타입을 가졌었다:

```ocaml
let seq : 'a parser -> 'b parser -> ('a * 'b) parser
```

 즉, 두 파서를 번갈아 적용해서 두 파서의 결과를 튜플로 묶는
 연산이다. 얼핏 보기에 `seq` 컴비네이터는 자연스러운 합성 연산으로
 보인다. 하지만 실제로는 `seq`을 계속 사용하다 보면 그 결과로 엄청나게
 중첩된 튜플을 갖게 되는데, 이를 다루는 것은 굉장히 지저분한 일이다.

 중첩된 튜플 문제는 *모나드식* 시퀀싱 컴비네이터를 적용해서 피할 수
 있다. 흔히 `바인드(bind)` 연산으로 알려진 것으로, 한 파서의 결과 값을
 처리해서 파서들을 시퀀싱하여 합치는 방식이다.

```ocaml


```
